package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.55

import (
	"context"
	"fmt"

	"github.com/filecoin-project/curio/web/api/webrpc"
	"github.com/samber/lo"
	"github.com/strahe/curio-dashboard/graph/cachecontrol"
	"github.com/strahe/curio-dashboard/graph/model"
	"github.com/strahe/curio-dashboard/types"
)

// MarketAddBalance is the resolver for the marketAddBalance field.
func (r *mutationResolver) MarketAddBalance(ctx context.Context, miner types.Address, wallet types.Address, amount types.FIL) (*model.MarketBalance, error) {
	_, err := r.curioAPI.MoveBalanceToEscrow(ctx, miner.String(), amount.String(), wallet.String())
	if err != nil {
		return nil, fmt.Errorf("failed to move balance to escrow: %w", err)
	}
	return r.Resolver.Query().MarketBalance(ctx, miner)
}

// MarketBalance is the resolver for the marketBalance field.
func (r *queryResolver) MarketBalance(ctx context.Context, miner types.Address) (*model.MarketBalance, error) {
	cachecontrol.SetHint(ctx, cachecontrol.ScopePrivate, marketDefaultCacheAge)
	balances, err := r.MarketBalances(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get market balances: %w", err)
	}
	for _, b := range balances {
		if b.Miner == miner {
			return b, nil
		}
	}
	return nil, fmt.Errorf("miner %s not found", miner)
}

// MarketBalances is the resolver for the marketBalances field.
func (r *queryResolver) MarketBalances(ctx context.Context) (res []*model.MarketBalance, err error) {
	cachecontrol.SetHint(ctx, cachecontrol.ScopePrivate, marketDefaultCacheAge)
	cacheKey := "marketBalances"
	if val, ok := r.cache.Get(cacheKey); ok {
		return val.([]*model.MarketBalance), nil
	}

	balances, err := r.curioAPI.MarketBalance(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get market balances: %w", err)
	}
	for _, b := range balances {
		res = append(res, &model.MarketBalance{
			Miner:   types.MustParseAddress(b.Miner),
			Balance: types.MustParseFIL(b.MarketBalance),
			Balances: lo.Map(b.Balances, func(x webrpc.WalletBalances, index int) *model.WalletBalance {
				return &model.WalletBalance{
					Address: types.MustParseAddress(x.Address),
					Balance: types.MustParseFIL(x.Balance),
				}
			}),
		})
	}
	r.cache.Add(cacheKey, res)
	return res, nil
}
