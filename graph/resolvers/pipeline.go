package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"
	"fmt"

	"github.com/strahe/curio-dashboard/graph"
	"github.com/strahe/curio-dashboard/graph/model"
)

// ID is the resolver for the id field.
func (r *pipelineResolver) ID(ctx context.Context, obj *model.Pipeline) (string, error) {
	return fmt.Sprintf("%d-%d", obj.SpID, obj.SectorNumber), nil
}

// Status is the resolver for the status field.
func (r *pipelineResolver) Status(ctx context.Context, obj *model.Pipeline) (model.PipelineStatus, error) {
	if obj.Failed {
		return model.PipelineStatusFailed, nil
	} else if obj.AfterCommitMsgSuccess {
		return model.PipelineStatusSuccess, nil
	} else if obj.AfterCommitMsg {
		return model.PipelineStatusCommitMsgWait, nil
	} else if !obj.AfterFinalize && obj.TaskIDFinalize != nil {
		return model.PipelineStatusClearCache, nil
	} else if !obj.AfterMoveStorage && obj.TaskIDMoveStorage != nil {
		return model.PipelineStatusMoveStorage, nil
	} else if !obj.AfterPorep && obj.AfterPrecommitMsgSuccess {
		return model.PipelineStatusPoRep, nil
	} else if !obj.AfterPrecommitMsgSuccess && obj.AfterPrecommitMsg {
		return model.PipelineStatusPreCommitMsgWait, nil
	} else if !obj.AfterPrecommitMsg && obj.AfterSynth {
		return model.PipelineStatusPreCommitMsg, nil
	} else if !obj.AfterSynth && obj.AfterTreeR {
		return model.PipelineStatusSynthetic, nil
	} else if !obj.AfterTreeR && obj.AfterTreeD {
		return model.PipelineStatusTreeRc, nil
	} else if !obj.AfterTreeD && obj.AfterTreeR {
		return model.PipelineStatusTreeD, nil
	} else if !obj.AfterSdr {
		return model.PipelineStatusSdr, nil
	} else {
		return model.PipelineStatusUnknown, nil
	}
}

// CurrentTask is the resolver for the currentTask field.
func (r *pipelineResolver) CurrentTask(ctx context.Context, obj *model.Pipeline) (*model.Task, error) {
	status, err := r.Status(ctx, obj)
	if err != nil {
		return nil, err
	}
	var taskID *int
	switch status {
	case model.PipelineStatusSdr:
		taskID = obj.TaskIDSdr
	case model.PipelineStatusTreeD:
		taskID = obj.TaskIDTreeD
	case model.PipelineStatusTreeRc:
		taskID = obj.TaskIDTreeC
	case model.PipelineStatusSynthetic:
		taskID = obj.TaskIDSynth
	case model.PipelineStatusPreCommitMsg:
		taskID = obj.TaskIDPrecommitMsg
	case model.PipelineStatusPoRep:
		taskID = obj.TaskIDPorep
	case model.PipelineStatusMoveStorage:
		taskID = obj.TaskIDMoveStorage
	case model.PipelineStatusClearCache:
		taskID = obj.TaskIDFinalize
	case model.PipelineStatusCommitMsgWait:
		taskID = obj.TaskIDCommitMsg
	}
	if taskID != nil {
		task, err := r.loader.Task(ctx, *taskID)
		if err != nil {
			log.Warnf("Failed to load task %d: %s", *taskID, err)
			return nil, nil
		}
		return task, nil
	}
	return nil, nil
}

// Pipeline returns graph.PipelineResolver implementation.
func (r *Resolver) Pipeline() graph.PipelineResolver { return &pipelineResolver{r} }

type pipelineResolver struct{ *Resolver }
