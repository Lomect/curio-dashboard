package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.55

import (
	"context"
	"fmt"
	"time"

	"github.com/filecoin-project/curio/web/api/webrpc"
	"github.com/filecoin-project/go-address"
	"github.com/strahe/curio-dashboard/graph/cachecontrol"
	"github.com/strahe/curio-dashboard/graph/model"
	"github.com/strahe/curio-dashboard/graph/utils"
	"github.com/strahe/curio-dashboard/types"
)

// UpdateMarketMk12StorageAsk is the resolver for the updateMarketMk12StorageAsk field.
func (r *mutationResolver) UpdateMarketMk12StorageAsk(ctx context.Context, input model.MarketMk12StorageAskInput) (*model.MarketMk12StorageAsk, error) {
	if input.Price < 0 {
		return nil, fmt.Errorf("invalid Price: must be non-negative")
	}
	if input.VerifiedPrice < 0 {
		return nil, fmt.Errorf("invalid VerifiedPrice: must be non-negative")
	}
	if !utils.IsValidPieceSize(uint64(input.MinSize)) {
		return nil, fmt.Errorf("invalid MinSize: must be a valid piece size")
	}
	if !utils.IsValidPieceSize(uint64(input.MaxSize)) {
		return nil, fmt.Errorf("invalid MaxSize: must be a valid piece size")
	}
	if input.MaxSize < input.MinSize {
		return nil, fmt.Errorf("invalid size range: MaxSize must be greater than or equal to MinSize")
	}
	act, err := address.NewIDAddress(uint64(input.SpID))
	if err != nil {
		return nil, err
	}
	if _, err := r.Query().Actor(ctx, types.Address{Address: act}); err != nil {
		return nil, fmt.Errorf("invalid SpID: %w", err)
	}
	ask := webrpc.StorageAsk{
		SpID:          int64(input.SpID),
		Price:         int64(input.Price),
		VerifiedPrice: int64(input.VerifiedPrice),
		MinSize:       int64(input.MinSize),
		MaxSize:       int64(input.MaxSize),
		CreatedAt:     time.Now().Unix(),
		Expiry:        int64(input.Expiry),
	}
	if ask.Expiry == 0 {
		ask.Expiry = time.Now().Add(time.Hour * 24 * 365).Unix()
	}
	err = r.curioAPI.SetStorageAsk(ctx, &ask)
	if err != nil {
		return nil, err
	}
	return r.Resolver.Query().MarketMk12StorageAsk(ctx, input.SpID)
}

// MarketMk12StorageAsks is the resolver for the marketMk12StorageAsks field.
func (r *queryResolver) MarketMk12StorageAsks(ctx context.Context) ([]*model.MarketMk12StorageAsk, error) {
	cachecontrol.SetHint(ctx, cachecontrol.ScopePrivate, marketMk12StorageAsksCacheAge)
	return r.loader.MarketStorageAskLoader.MarketMk12StorageAsks(ctx)
}

// MarketMk12StorageAsk is the resolver for the marketMk12StorageAsk field.
func (r *queryResolver) MarketMk12StorageAsk(ctx context.Context, spID types.ActorID) (*model.MarketMk12StorageAsk, error) {
	cachecontrol.SetHint(ctx, cachecontrol.ScopePrivate, marketMk12StorageAsksCacheAge)
	return r.loader.MarketStorageAskLoader.MarketMk12StorageAsk(ctx, int64(spID))
}

// MarketMk12StorageAsksCount is the resolver for the marketMk12StorageAsksCount field.
func (r *queryResolver) MarketMk12StorageAsksCount(ctx context.Context) (int, error) {
	cachecontrol.SetHint(ctx, cachecontrol.ScopePrivate, marketMk12StorageAsksCacheAge)
	return r.loader.MarketStorageAskLoader.MarketMk12StorageAsksCount(ctx)
}
